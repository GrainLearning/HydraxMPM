{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":""},{"location":"#installation","title":"Installation","text":"<ul> <li>Install uv here</li> <li>Clone repository <code>git clone git@github.com:GrainLearning/HydraxMPM.git &amp;&amp; cd HydraxMPM</code></li> <li>Install dependencies <code>uv sync</code></li> </ul>"},{"location":"#quick-simulation","title":"Quick simulation","text":"<ul> <li>Run an example, e.g., <code>uv run examples/dambreak/dambreak.py</code>. Output is found in the <code>./examples/dambreak/</code> directory.</li> </ul>"},{"location":"#next-steps","title":"Next steps","text":""},{"location":"#whats-in-the-box","title":"Whats in the box?","text":"<ul> <li>Plane strain</li> </ul>"},{"location":"about/","title":"Et orbem spretae in vera ubi Prima","text":""},{"location":"about/#primo-contigit-nebulasque-animal-nigro","title":"Primo contigit nebulasque animal nigro","text":"<p>Lorem markdownum Talia, tremescere deus iamdudum excipit madent inaniter anili Austri fuit precor signa superest adunci magnus, inpia. Facta tam est frondibus, tellus quaedam fisa tibi insula capitis superem nec speculabar, deque castris? Sub gentes periclo tenebrisque pone, hostem nemorum vixque trahens medio, cruor. Arvo genus, est rogantem fine: atria, crimen.</p> <ol> <li>Et temperat ad fortiter honore inritaturque pallor</li> <li>Silvae solvit dolore ponar ipsa relictum</li> <li>Ademptis non per nec caper iram virum</li> </ol> <p>Me ponit, magna murmura infundere quae, memoratis primum vites, condar! Multifidasque unde: abscidit falsi longius, mora sit e morsu aliqua inposuitque ante rex ubi referunt datur ab intus. Illius medius incipit relinquitur temerarius postquam, aut urbi quod tacitus mirantem corniger, fiet caesa, ille.</p> <ul> <li>Dedit videndo aether reccidit volatu adclivis metaque</li> <li>Creavit talibus</li> <li>Non nisi nocet paelice extrema</li> </ul>"},{"location":"about/#ultaque-spolium-enixa-patriosque-populo","title":"Ultaque spolium enixa patriosque populo","text":"<p>Quem solis, laudat aut percutimurque remis, nunc suis maturuit, respicit anguem; est Ianthe, ora formam. Pulchro Almo herosmaxime folioque virtus est ruere iactis, ense non praesagaque at unde patulas.</p> <ul> <li>Scrobe amat nos translata exacta si nec</li> <li>Repellit ubi legi et potes ut mittentis</li> <li>Litore voluntas Iuppiter Propoetidas Caesarea coniuge</li> <li>Absumitur herbarum gemitu</li> <li>Titaniacis nec</li> <li>Ruinam herbis</li> </ul> <p>Naiadum omnes sui tui dorso adloquitur in arcana aliis cum, parari. Natura qua manus sit et adsumptumque credite certe decidit profugam, veneno, videres cuspide. Pectore quam totidem solebat urbes antistita humo educere solidis gentis novi: patulosque.</p> <p>Nymphis vincendo Aetola. Cumque obortas odorato voces possint canis: similem hic mediis facit deum at longissima umoris.</p> <p>Regnorum haut dolebo celebrant illa falcato Aeacidae vicibus auras colla tam qui quae austroque parere temptatis poplitibus tempus nympharum dubites. Astris sub alta ipsorum tardior utinam totas, Anaxaretes senesque namque qui deprensa nymphe ignis vitiatur Phiale in. Formicas florebat inmenso coniunx iam emicat saepe quo gemitu dataque Hippomenen esse. Si pudoris arbor Claninque duos nescit atro inquit: quoniam, conpressit tempore noctis vastique.</p>"},{"location":"basics/","title":"The Basics","text":""},{"location":"basics/#code-structure","title":"Code structure","text":"<p>HydraxMPM follows an array of structures design. That is, a set of scalars has a shape <code>(number of material points,)</code>, vectors <code>(number of material points, dimension)</code>, tensors <code>(number of material points, dimension)</code>. These arrays are typically denoted as stacks (e.g., <code>mass_stack</code>, <code>velocity_stack</code>). Some arrays are always defined in 3D, e.g., the deformation gradient <code>F_stack</code>, which has a shape <code>(number of material points,3)</code>.</p> <ul> <li>Objects are defined as dataclasses, common practice in JAX</li> </ul>"},{"location":"advance/custom_models/","title":"Custom models","text":""},{"location":"api/config/","title":"Configuration","text":"<p>A configuration data object is passed down to all <code>HydraxMPM</code> objects. This pre-allocates necessary memory for simulations.</p> <p>Two config types are available:</p> <ul> <li><code>MPMConfig</code>: For Material Point Method (MPM) simulations.</li> <li><code>IPConfig</code>: For single integration point element tests.</li> </ul> <p>Modifying config</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"api/config/#mpmconfig","title":"MPMConfig","text":""},{"location":"api/config/#config.mpm_config.MPMConfig.__init__","title":"<code>__init__(origin, end, cell_size, num_points=0, shapefunction='cubic', ppc=1, num_steps=0, store_every=0, dt=0.0, default_gpu_id=None, project='', device=None, **kwargs)</code>","text":"<p>Parameters:</p> <ul> <li> <code>origin</code>               (<code>list</code>)           \u2013            <p>domain start</p> </li> <li> <code>end</code>               (<code>list</code>)           \u2013            <p>domain end</p> </li> <li> <code>cell_size</code>               (<code>float</code>)           \u2013            <p>cell size of grid</p> </li> <li> <code>num_points</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>number of material points. Defaults to 0.</p> </li> <li> <code>shapefunction</code>               (<code>str</code>, default:                   <code>'cubic'</code> )           \u2013            <p>Shapefunction type, select:[\"cubic\",\"linear\"]. Defaults to \"cubic\".</p> </li> <li> <code>ppc</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>number of particles discretized per cell. Defaults to 1.</p> </li> <li> <code>num_steps</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>number of steps to run. Defaults to 0.</p> </li> <li> <code>store_every</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>output every nth step. Defaults to 0.</p> </li> <li> <code>dt</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>constant time step. Defaults to 0.0.</p> </li> <li> <code>default_gpu_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>default gpu to run on. Defaults to None.</p> </li> <li> <code>project</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>project name. Defaults to \"\".</p> </li> <li> <code>device</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>sharding (not implemented yet). Defaults to None.</p> </li> </ul>"},{"location":"api/config/#config.mpm_config.MPMConfig.print_summary","title":"<code>print_summary()</code>","text":"<p>Print a basic summary of the config</p>"},{"location":"api/config/#ipconfig","title":"IPConfig","text":"<p>Integration Point Config</p>"},{"location":"api/config/#config.mpm_config.MPMConfig.__init__","title":"<code>__init__(origin, end, cell_size, num_points=0, shapefunction='cubic', ppc=1, num_steps=0, store_every=0, dt=0.0, default_gpu_id=None, project='', device=None, **kwargs)</code>","text":"<p>Parameters:</p> <ul> <li> <code>origin</code>               (<code>list</code>)           \u2013            <p>domain start</p> </li> <li> <code>end</code>               (<code>list</code>)           \u2013            <p>domain end</p> </li> <li> <code>cell_size</code>               (<code>float</code>)           \u2013            <p>cell size of grid</p> </li> <li> <code>num_points</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>number of material points. Defaults to 0.</p> </li> <li> <code>shapefunction</code>               (<code>str</code>, default:                   <code>'cubic'</code> )           \u2013            <p>Shapefunction type, select:[\"cubic\",\"linear\"]. Defaults to \"cubic\".</p> </li> <li> <code>ppc</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>number of particles discretized per cell. Defaults to 1.</p> </li> <li> <code>num_steps</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>number of steps to run. Defaults to 0.</p> </li> <li> <code>store_every</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>output every nth step. Defaults to 0.</p> </li> <li> <code>dt</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>constant time step. Defaults to 0.0.</p> </li> <li> <code>default_gpu_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>default gpu to run on. Defaults to None.</p> </li> <li> <code>project</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>project name. Defaults to \"\".</p> </li> <li> <code>device</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>sharding (not implemented yet). Defaults to None.</p> </li> </ul>"},{"location":"api/config/#config.mpm_config.MPMConfig.print_summary","title":"<code>print_summary()</code>","text":"<p>Print a basic summary of the config</p>"},{"location":"api/shapefunctions/","title":"Shapefunctions","text":""},{"location":"api/shapefunctions/#linear","title":"Linear","text":"<p>This is the simplest which is discontinious and prone to instabilities.</p> <p>Example</p> <pre><code>    import hydraxmpm as hdx\n\n    config = hdx.MPMConfig(\n        shapefunction=\"linear\"\n    )\n</code></pre> <p>References:</p> <ol> <li> <p>De Vaucorbeil, Alban, et al. 'Material point method after 25 years: theory, implementation, and applications.' --&gt;\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/two_sphere_impact/","title":"Two sphere impact","text":""},{"location":"how-tos/initialize_material_points/","title":"Initialize material points","text":"<p>This is empty and sad, wait until its happier :(</p>"},{"location":"tutorials/1_granular_column/","title":"Tutorials","text":""},{"location":"tutorials/1_granular_column/#tutorial-1-granular-column-collapse","title":"Tutorial 1. Granular column collapse","text":"<p>In this tutorial, we'll simulate a very simple basic granular column collapse with the modified Cam-Clay. The simulation involves two parts: (1) gravity pack and (2) collapse.</p>"},{"location":"tutorials/1_granular_column/#pre-requisites","title":"Pre-requisites:","text":"<p>Before starting, please make sure that you have completed the following items:</p> <ol> <li>Installed the HydraxMPM.</li> <li>Comfortable with JAX - basics, and  JAX - The Sharp Bits</li> <li>Read through an overview of the code structure</li> <li>Have Paraview</li> </ol> <p>It is recommended that you follow along with the tutorial. Stuck or in a rush? then see code available in GitHub under /tutorials/t1_granular_column.py.</p>"},{"location":"tutorials/1_granular_column/#learning-objectives","title":"Learning objectives","text":"<p>By the end of this tutorial you will be able to </p> <ul> <li>Understand the overall code style of a HydraxMPM script</li> </ul>"},{"location":"tutorials/1_granular_column/#step-1-create-the-project-file-and-folders","title":"Step 1: create the project file and folders","text":"<p>Create a project directory containing the driver script and two sub-folders with as follows:</p> <p><pre><code># driver script\n/tutorial/t1_granular_column.py  \n\n# output of gravity pack\n/tutorial/output/t1_pack/ \n\n# output of collapse\n/tutorial/output/t2_collapse  \n</code></pre> The output is stored as vtk files in the <code>/tutorial/output/t1_pack/</code> and <code>/tutorial/output/t2_collapse/</code> folders, respectively.</p>"},{"location":"tutorials/1_granular_column/#step-2-import-modules","title":"Step 2: import modules","text":"<p>Import HydraxMPM and supporting the JAX dependencies. </p> <pre><code>import jax\nimport jax.numpy as jnp\nimport hydraxmpm as hdx\n</code></pre> <p>HydraxMPM is top-level package. It contains all the bits and pieces under the same namespace, e.g., <code>hdx.Particles</code> or <code>hdx.Gravity</code>.</p>"},{"location":"tutorials/1_granular_column/#step-3-create-points-representing-initial-granular-column","title":"Step 3: create points representing initial granular column","text":"<p>Create rectangular column a rectangular column of material points. Particles are spaced evenly given a cell size and the number of particles per cell (in one direction). We pad so that material points do not touch the boundary. </p> <pre><code>column_width = 0.3  # [m]\ncolumn_height = 0.4  # [m]\nppc = 2\n\n\ncell_size = 0.025  # [m]\nsep = cell_size / ppc\npadding = 4.5 * sep\n\n# create padded meshgrid of positions \nx = jnp.arange(0, column_width + sep, sep) + padding - sep \ny = jnp.arange(0, column_height + sep, sep) + padding - sep\nxv, yv = jnp.meshgrid(x, y)\n\nposition_stack = jnp.array(list(zip(xv.flatten(), yv.flatten())))\n</code></pre> Tip <p>There are several ways of initializing material points. See the how-to initialize material points .</p> Tip <p>Matplotlib or Pyvista may be used visualize initial positions. To visualize the particles copy and paste the following (note plt.show works only when GUI is active).  <pre><code>    import matplotlib.pyplot as plt\n\n    plt.scatter(*position_stack.T ) # unpack x and y and plot\n    plt.show() # or plt.savefig(\"packing.png\")\n</code></pre></p>"},{"location":"tutorials/1_granular_column/#step-4-create-the-simulation-config","title":"Step 4: create the simulation config","text":"<p>This is a juicy sandwich of all common general simulation parameters.</p> <p><pre><code>config = hdx.MPMConfig(\n    origin=jnp.array([0.0, 0.0]),\n    end=jnp.array([column_width +  padding+2*sep, 0.5]),\n    project=\"t1_pack\",\n    ppc=ppc,\n    cell_size=cell_size,\n    num_points=len(position_stack),\n    shapefunction=\"cubic\",\n    num_steps=60000,\n    store_every=500,\n    default_gpu_id=0,\n    dt=3 * 10**-5,  # time step[s]\n    file=__file__,  # store current location of file for output\n)\n</code></pre>  Ok... it seems like a lot, but actually pretty straight forward:</p> <ul> <li><code>hdx.MPMConfig</code> is the config dataclass used for all MPM simulations.</li> <li><code>origin</code> contains start x and y coordinates of the domain boundary</li> <li><code>end</code> contains end x and y coordinates of the domain</li> <li><code>project</code> is the name of the project - mainly used for output purposes</li> <li><code>ppc</code> is the number of particles per cell (in one direction). this is only used in <code>hdx.discretize</code> function (more on that later)</li> <li><code>cell_size</code> is background grid cell size</li> <li><code>num_points</code> is number of material points</li> <li><code>shapefunction</code> the interpolation type from particle to grid. Two shapefunctions are supported, either <code>linear</code> or <code>cubic</code>. Cubic is better in most cases.</li> <li><code>num_steps</code> the total iteration count</li> <li><code>store_every</code> output every nth step</li> <li><code>default_gpu_id</code> if you are working on a shared GPU workstation, this is the parameter you change to avoid making the other person(s) angry! Run <code>nvidia-smi</code>, in your terminal to find the id of an empty GPU. </li> <li><code>dt</code> is a constant time step</li> <li><code>file=__file__</code> this records the path of your driver script, which is important to save relative output in the correct folder.</li> </ul> Tip <p><code>origin</code> and <code>end</code> will be of len 2 for 2D plane strain (x,y), and len 3 for 3D (x,y,z).</p> why a master config? <p>This is an easy way to ensure, same size arrays are set throughout all dataclasses.</p> <p>Lets see the summary of the config <pre><code>config.print_summary()\n</code></pre> If all went well you should get the following output:</p> <pre><code>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nproject: tutorial1\ndim: 2\nnum_points: 625\nnum_cells: 1400\nnum_interactions: 10000\ndomain origin: (0, 0)\ndomain end: (1.399999976158142, 0.6000000238418579)\ndt: 3.0000000000000004e-05\ntotal time: 12.000000000000002\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>"},{"location":"tutorials/1_granular_column/#step-4-create-the-material","title":"Step 4: create the <code>Material</code>","text":"<p>Lets create a material with some initial bulk density and a particle density</p> <pre><code># Initial bulk density material parameters\nphi_0 = 0.8  # [-] initial solid volume fraction\nrho_p = 1400  # [kg/m^3] particle (skeletan density)\nrho_0 = rho_p * phi_0  # [kg/m^3] initial bulk density\n</code></pre> <p>Now the material dataclass</p> <pre><code>material = hdx.ModifiedCamClay(\n    config=config,\n    nu=0.3,\n    M=0.7,\n    R=1,\n    lam=0.0186,\n    kap=0.0010,\n    rho_p=rho_p,\n    p_t=1.0,\n    ln_N=jnp.log(1.29),\n    phi_ref_stack=phi_0 * jnp.ones(config.num_points),\n)\n</code></pre> <p>Lets break this down:</p> <ul> <li><code>hdx.ModifiedCamClay</code> is the Modified Cam Clay material class</li> <li>We always pass <code>config</code> along when creating HydraxMPM dataclasses.</li> <li>The only non-parameter input is the reference solid volume fraction. </li> </ul> <p>Tip</p> <p>Materials in HydraxMPM are normally initialize either with a reference pressure or reference solid volume fraction. Given one, we can find the other.</p> Tip <p>Material may be used in MPM analysis or single integration analysis. Sometimes its good to do both</p>"},{"location":"tutorials/1_granular_column/#step-5-create-the-nodes-and-particles-data-classes","title":"Step 5: create  the <code>Nodes</code> and <code>Particles</code>  data classes","text":"<p>We initialize particle stresses to match the known pressure state, given a predefined solid-volume fraction above. </p> <p>Here we finally make use of JAX vmap, to get the stress tensor. </p> <pre><code>def get_stress_ref(p_ref):\n    return -p_ref * jnp.eye(3)\n\nstress_stack = jax.vmap(get_stress_ref)(material.p_ref_stack)\n</code></pre> <p>Pass all positions and stresses to the <code>Particles</code> dataclass. <pre><code>particles = hdx.Particles(\n    config=config, position_stack=position_stack, stress_stack=stress_stack\n)\n</code></pre> We can create background grid nodes via the config.</p> <pre><code>nodes = hdx.Nodes(config)\n</code></pre> <p>The <code>discretize</code> function determines initial particle volume by dividing the number of particles in a cell by the cell size. <pre><code>particles, nodes = hdx.discretize(\n    config=config, particles=particles, nodes=nodes, density_ref=rho_0\n)\n</code></pre></p>"},{"location":"tutorials/1_granular_column/#step-6-create-the-gravity-and-domain","title":"Step 6: create the <code>Gravity</code> and <code>Domain</code>","text":"<p>Gravity is slowly ramped up </p> <pre><code>stop_ramp_step = config.num_steps\n\nincrement = jnp.array([0.0, -9.8]) / stop_ramp_step\n\ngravity = hdx.Gravity(config=config, increment=increment, stop_ramp_step=stop_ramp_step)\n</code></pre> <p>Creating the outside domain box.</p> <pre><code>box = hdx.NodeLevelSet(config, mu=0.0)\n</code></pre>"},{"location":"tutorials/1_granular_column/#step-7-create-the-solver","title":"Step 7: create the <code>Solver</code>","text":"<p>The solver determines how the background grid and material points interact.</p> <pre><code>solver = hdx.USL_ASFLIP(config)\n</code></pre> Tip <p>We recommend using the <code>hdx.ASFLIP</code> for granular  materials</p>"},{"location":"tutorials/1_granular_column/#step-8-run-gravity-pack","title":"Step 8: Run gravity pack","text":"<ul> <li>See available callback functions</li> </ul> <pre><code>print(\"Start gravity pack\")\ncarry, accumulate = hdx.run_solver_io(\n    config=config,\n    solver=solver,\n    particles=particles,\n    nodes=nodes,\n    material_stack=[material],\n    forces_stack=[gravity, box],\n    callbacks=(\n        hdx.io_vtk_callback(\n            config,\n            particle_output=(\n                \"stress_stack\",\n                \"phi_stack\",\n            ),\n        ),\n    ),\n)\n\nsolver, particles, new_nodes, material_stack, forces_stack = carry\nprint(\"Gravity pack done\")\n</code></pre>"},{"location":"tutorials/1_granular_column/#step-9-modify-script-to-incorporate-collapse","title":"Step 9: Modify script to incorporate collapse","text":"<pre><code>config = config.replace(\n    origin=jnp.array([0.0, 0.0]),\n    end=jnp.array([1.2, 0.5]),\n    project=\"t2_collapse\",\n)\n\nsolver = hdx.USL_ASFLIP(config)\n\nnodes = hdx.Nodes(config)\n\ngravity = hdx.Gravity(config=config, gravity=jnp.array([0.0, -9.8]))\n\nbox = hdx.NodeLevelSet(config, mu=0.7)\n</code></pre>"},{"location":"tutorials/1_granular_column/#step-10-granular-column-collapse","title":"Step 10: Granular column collapse","text":"<pre><code>carry, accumulate = hdx.run_solver_io(\n    config=config,\n    solver=solver,\n    particles=particles,\n    nodes=nodes,\n    material_stack=material_stack,\n    forces_stack=[gravity, box],\n    callbacks=(\n        hdx.io_vtk_callback(\n            config,\n            particle_output=(\n                \"pressure_stack\",\n                \"phi_stack\",\n            ),\n        ),\n    ),\n)\n\nprint(\"Collapse done\")\n</code></pre>"},{"location":"usage/","title":"Basic usage","text":""},{"location":"usage/#sampling-particles","title":"Sampling particles","text":""},{"location":"usage/#rigid-body-contacts","title":"Rigid body contacts","text":""},{"location":"usage/#visualizing-results","title":"Visualizing results","text":""}]}